# RRT Path Planning - BYU ME-537 Robotics Project
This repository contains my libraries and code for a Robotics class Final Project I completed with a classmate, Ryan Hall. We implemented a unique form of Rapidly Exploring Random Trees (RRT) to plan a path for a robot arm. The unique nature of my RRT algorithm involved the method we used to generate each node in my tree. Rather than generating a random point in space and attaching to the nearest neighbor, we selected a parent node first and propagated in a random direction from there.

![Image of successful completion of an RRT path](/Video+Images/PlannedPath1b.png)
![Image of successful completion of an RRT path](/Video+Images/PointCloud.png)


Tunable parameters in this code include:
  - Magnitude of bias towards the goal
  - Number of children nodes to generate for each parent
  - Step size
  - Placement and size of obstacles

After the RRT algorithm has identified a viable path from start-finish that successfully navigates the obstacles, a simple path-smoothing algorithm attempts to cut out intermediate nodes by searching for "line-of-sight" between different nodes on the path. The final path is then converted into a series of points, which are fed into an IK controller (Damped-Psuedo Inverse method) that models the behavior of a small robot arm tracing the path.

Strengths of this algorithm:
  - This RRT method is able to iterate extremely quickly because each parent node is known prior to the creation of a new node. This eliminates the need to search through the existing tree when each node is created
  - The line-of-sight smoothing method is also very fast since it only looks at the history of nodes associated with the final path.

Weaknesses of this algorithm:
  - The known-parent approach results in a high point density at the start and low density at the end. This means that the number of points required to obtain a path increases exponentially with decreasing step size.
  - The blocks of code that check for interence with obstacles do not consider the behavior of the robot arm. T,his enables greater speed in the algorithm, but only guarantees the end effector will avoid the obstacles. The IK control similarly does not take obstacle placement into account, nor does it check for self-interference.
  - The path smoothing algorithm only analyzes points on the final path, and does not attempt to minimize the travel distance of the end effector by searching through the entire set of points in the tree.
 
In addition to the Python code, there are some Arduino files for running multiple steppers with non-blocking code. The original intent was to set up an Arduino Nano to function as a ROS node via Rosserial (ROS1), which would then accept joint angles generated by the IK function. However, the project did not progress beyond simulation based on time constraints with the end of the semester. However, there are some Eagle PCB files that present the schematic and board layout for the Arduino Nano and stepper motors.
